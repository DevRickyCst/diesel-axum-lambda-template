# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Production-grade Rust web service template using Axum, Tokio, Diesel (PostgreSQL). Supports both local HTTP server and AWS Lambda deployment via `lambda_http`. The template demonstrates clean layered architecture with a complete CRUD example for "Tasks" entities.

## Essential Commands

### Local Development
```bash
# Start local stack (app + PostgreSQL)
make local

# Start in background
make local-detached

# Stop all containers
make stop

# Run database migrations
make migrate

# Revert last migration
make revert

# Run all tests
make test

# Run specific test
make test t=test_name

# Build the project
cargo build

# Run locally (requires PostgreSQL and env vars)
cargo run

# Format and lint
cargo fmt
cargo clippy --all-targets --all-features -- -D warnings
```

### AWS Lambda Deployment
```bash
# Build Lambda package
make build-lambda

# Deploy to AWS (requires AWS CLI and SAM CLI)
make deploy-lambda
```

### Database Operations
```bash
# Setup database and run migrations
diesel setup
diesel migration run

# Revert last migration
diesel migration revert

# Open PostgreSQL shell
make db-shell

# Reset database (WARNING: deletes all data)
make db-reset
```

## Architecture

### Layered Design (Mandatory)

The codebase follows strict layering to separate concerns:

1. **HTTP Layer** (`src/handlers/`, `src/app.rs`)
   - Axum route handlers are thin - they ONLY validate input, call services, and map errors to HTTP responses
   - NO business logic in handlers
   - Request/response types in `src/api/` module

2. **Service Layer** (`src/services/`)
   - ALL business logic lives here
   - Services coordinate between repositories and domain logic
   - Input validation happens at this layer

3. **Persistence Layer** (`src/db/`)
   - All database access isolated in `src/db/repositories/`
   - NO Diesel queries outside repositories
   - Models in `src/db/models/`
   - Schema in `src/db/schema.rs` (generated by Diesel)
   - Connection pooling via r2d2 with OnceLock in `src/db/connection.rs`

### API Types Module (`src/api/`)

The `src/api/` module contains all public API types designed for reusability. This module is organized to potentially be extracted as a separate client SDK crate:

- `requests.rs` - Request DTOs (CreateTaskRequest, UpdateTaskRequest, etc.)
- `responses.rs` - Response DTOs (TaskResponse, etc.)
- `error.rs` - Public error format (ErrorResponse)
- `result.rs` - Generic response wrapper (AppResponse<T>)

All handlers should use `AppResponse<T>` for consistent response formatting:
```rust
// 200 OK
Ok(AppResponse::ok(data))

// 201 Created
Ok(AppResponse::created(data))

// 204 No Content
Ok(AppResponse::no_content())

// With custom headers
Ok(AppResponse::ok(data).with_headers(headers))
```

### Key Modules

- **`src/api/result.rs`** - AppResponse pattern for consistent HTTP responses
- **`src/api/error.rs`** - Public ErrorResponse DTO
- **`src/error.rs`** - Application-wide error types and HTTP mapping
- **`src/app.rs`** - Router setup, middleware configuration (tracing)
- **`src/main.rs`** - Entrypoint; selects execution mode (local vs Lambda)
- **`src/services/`** - Business logic layer
- **`src/db/repositories/`** - Database access layer

## Configuration

Environment variables required:

```env
# App
APP_ENV=development
SERVER_HOST=0.0.0.0
SERVER_PORT=3000
RUST_LOG=debug

# Database
DATABASE_URL=postgres://postgres:postgres@db:5432/{{database_name}}
DB_POOL_MAX_SIZE=15

# PostgreSQL (for Docker)
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_DB={{database_name}}
```

## Code Style & Rules

### Mandatory Architecture Rules

- HTTP handlers must be thin (no business logic)
- Core logic lives in `src/services/`
- Database access isolated in `src/db/repositories/`
- NO global mutable state (use OnceLock for initialization)
- Secrets and keys are NEVER hardcoded

### Rust Style

- Idiomatic Rust
- Prefer explicit types over inference in public APIs
- Use `Result<T, E>` consistently
- NEVER use `unwrap()` or `expect()` in production code (except for initialization panics)
- Early returns over nested conditionals
- Functions should be small and single-purpose
- Use `chrono` with UTC only
- UUIDs for identifiers

### Error Handling

- Add context to errors using `anyhow::Context`
- NEVER leak sensitive information in errors
- Map internal errors to appropriate HTTP responses in handlers
- Use explicit domain error types; `anyhow` only at boundaries

### Async & Performance

- All I/O must be async
- NEVER use blocking calls in async contexts
- Use connection pooling (r2d2 with OnceLock) correctly
- NO heavy computation in request handlers

### Security

- NEVER log secrets or sensitive data
- Prefer deny-by-default authorization logic
- Validate input at service layer

## Testing

Tests are run via Docker Compose to ensure a clean database environment:

```bash
# Run all tests
make test

# Run specific test
make test t=test_task

# Run with more verbose output
make test t=test_name -- --nocapture

# Run tests in watch mode
make test-watch
```

### Testing Guidelines

- Favor unit tests for services and repositories
- Use integration tests for HTTP routes
- Mock database access when possible
- Tests must be deterministic
- Clean up test data after tests (delete created resources)

## Common Workflows

### Adding New Endpoint

1. Create request/response DTOs in `src/api/requests.rs` and `src/api/responses.rs`
2. Implement business logic in `src/services/` (or create new service module)
3. If needed, create repository methods in `src/db/repositories/`
4. Create handler in `src/handlers/` - keep it thin, delegate to service
5. Register route in `src/app.rs`
6. Add tests

### Database Schema Changes

1. Create migration: `diesel migration generate migration_name`
2. Write `up.sql` and `down.sql` in `migrations/`
3. Apply migration: `make migrate` (or `diesel migration run`)
4. Update models in `src/db/models/` if needed
5. Update repositories in `src/db/repositories/` if needed
6. Schema in `src/db/schema.rs` is auto-generated by Diesel

### Error Mapping

Application errors flow through `src/error.rs` which maps domain errors to HTTP status codes. When adding new error types, ensure proper mapping to HTTP responses and that no sensitive data leaks.

## Execution Modes

The service has two runtime modes selected in `src/main.rs`:

- **Local HTTP Server**: Standard Axum server under Tokio for development (port 3000 by default)
- **AWS Lambda**: Uses `lambda_http` adapter for serverless deployment

Detection is based on `AWS_LAMBDA_FUNCTION_NAME` environment variable.

## Resources

- Health endpoint: `GET /health`
- Tasks CRUD endpoints: See API section in README.md

## Notes

- This is Rust edition 2024
- Keep queries inside repositories; avoid raw SQL in handlers/services
- Use `tracing` macros (`info!`, `warn!`, `error!`, `debug!`) for logging
- Format: GitHub-flavored markdown when documenting
